# 分析文档
## 教材中语句执行分析
### 执行截图
* 查询1截图：

![图片加载失败](https://github.com/hwrbox/Oracle/blob/master/%E6%B5%8B%E8%AF%95/4.PNG)
![图片加载失败](https://github.com/hwrbox/Oracle/blob/master/%E6%B5%8B%E8%AF%95/1.png)
![图片加载失败](https://github.com/hwrbox/Oracle/blob/master/%E6%B5%8B%E8%AF%95/1-1.PNG)
* 查询2截图：

![图片加载失败](https://github.com/hwrbox/Oracle/blob/master/%E6%B5%8B%E8%AF%95/2.png)


在我看来，两个查询语句之间的差别只是将最后两句代码进行了顺序的调换，其他的并没有什么差别，然而having是分组（group by）后的筛选条件，在分组后的数据组内再筛选，而where则是在分组前筛选，先进行了筛选后再分组，使得查询步骤更加简化。查询一有一次索引搜索access，一次全表搜索filter,而查询二有一次索引搜索access，两次次全表搜索filter，查询一其他参数都优于查询二，所以查询一的SQL语句更优。

### 查询一优化指导
经过优化指导后，查询一有两次索引搜索access，而没有全表搜索filter，其他的指标也有提升，其执行计划如下：
```
1- Index Finding (see explain plans section below)
--------------------------------------------------
  通过创建一个或多个索引可以改进此语句的执行计划。

  Recommendation (estimated benefit: 59.99%)
  ------------------------------------------
  - 考虑运行可以改进物理方案设计的访问指导或者创建推荐的索引。
    create index HR.IDX$$_000B0001 on HR.DEPARTMENTS("DEPARTMENT_NAME","DEPARTM
    ENT_ID");

  Rationale
  ---------
    创建推荐的索引可以显著地改进此语句的执行计划。但是, 使用典型的 SQL 工作量运行 "访问指导"
    可能比单个语句更可取。通过这种方法可以获得全面的索引建议案, 包括计算索引维护的开销和附加的空间消耗。
2- Using New Indices
--------------------
Plan hash value: 4174297859

 
---------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name              | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |                   |     2 |    46 |     2   (0)| 00:00:01 |
|   1 |  SORT GROUP BY NOSORT         |                   |     2 |    46 |     2   (0)| 00:00:01 |
|   2 |   NESTED LOOPS                |                   |    19 |   437 |     2   (0)| 00:00:01 |
|   3 |    NESTED LOOPS               |                   |    20 |   437 |     2   (0)| 00:00:01 |
|   4 |     INLIST ITERATOR           |                   |       |       |            |          |
|*  5 |      INDEX RANGE SCAN         | IDX$$_000B0001    |     2 |    32 |     1   (0)| 00:00:01 |
|*  6 |     INDEX RANGE SCAN          | EMP_DEPARTMENT_IX |    10 |       |     0   (0)| 00:00:01 |
|   7 |    TABLE ACCESS BY INDEX ROWID| EMPLOYEES         |    10 |    70 |     1   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------------
 
Query Block Name / Object Alias (identified by operation id):
-------------------------------------------------------------
 
   1 - SEL$1
   5 - SEL$1 / D@SEL$1
   6 - SEL$1 / E@SEL$1
   7 - SEL$1 / E@SEL$1
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   5 - access("D"."DEPARTMENT_NAME"='IT' OR "D"."DEPARTMENT_NAME"='Sales')
   6 - access("D"."DEPARTMENT_ID"="E"."DEPARTMENT_ID")
 
Column Projection Information (identified by operation id):
-----------------------------------------------------------
 
   1 - (#keys=1) "DEPARTMENT_NAME"[VARCHAR2,30], COUNT("E"."SALARY")[22], COUNT(*)[22], 
       SUM("E"."SALARY")[22]
   2 - (#keys=0) "DEPARTMENT_NAME"[VARCHAR2,30], "E"."SALARY"[NUMBER,22]
   3 - (#keys=0) "DEPARTMENT_NAME"[VARCHAR2,30], "E".ROWID[ROWID,10]
   4 - "D"."DEPARTMENT_ID"[NUMBER,22], "DEPARTMENT_NAME"[VARCHAR2,30]
   5 - "D"."DEPARTMENT_ID"[NUMBER,22], "DEPARTMENT_NAME"[VARCHAR2,30]
   6 - "E".ROWID[ROWID,10]
   7 - "E"."SALARY"[NUMBER,22]



```
## 自定义语句
* SQL语句：
```sql

```
* 查询结果：
